- helper_version: helper:v20251223.1
- focus: ADR-0063 §Talon Adapter Layer (map CLI error payloads to Talon notifications)
- riskiest_assumption: Without error payload handling, CLI failures would return silently, preventing Talon from surfacing guardrail messages (probability medium, impact high on UX).
- validation_targets:
  - python3 - <<'PY'
      import sys
      from pathlib import Path
      from types import SimpleNamespace
      from unittest.mock import patch
      sys.path.insert(0, str(Path('.').resolve()))
      from bootstrap import bootstrap
      bootstrap()
      from talon_user.lib import providerCommands
      with (
          patch.object(providerCommands.settings, 'get', return_value=1),
          patch.object(providerCommands, '_bar_cli_command', return_value=Path('/tmp/bar')),
          patch.object(providerCommands.subprocess, 'run', return_value=SimpleNamespace(returncode=0, stdout='{"error":"cli failed"}', stderr='')),
          patch.object(providerCommands, 'notify') as notify_mock,
          patch('talon_user.lib.providerCommands.print') as print_mock,
      ):
          result = providerCommands._delegate_to_bar_cli('model_provider_status')
          if not result:
              raise SystemExit('delegation returned False when error payload present')
      notify_mock.assert_called_once_with('cli failed')
      printed = ' '.join(str(arg) for arg in print_mock.call_args[0])
      if 'cli failed' not in printed:
          raise SystemExit('debug log missing cli failed message')
      print('error payload handled')
    PY
- evidence:
  - red | 2026-01-02T00:24:32Z | exit 1 | python3 - <<'PY'
      import sys
      from pathlib import Path
      from types import SimpleNamespace
      from unittest.mock import patch
      sys.path.insert(0, str(Path('.').resolve()))
      from bootstrap import bootstrap
      bootstrap()
      from talon_user.lib import providerCommands
      with (
          patch.object(providerCommands.settings, 'get', return_value=1),
          patch.object(providerCommands, '_bar_cli_command', return_value=Path('/tmp/bar')),
          patch.object(providerCommands.subprocess, 'run', return_value=SimpleNamespace(returncode=0, stdout='{"error":"cli failed"}', stderr='')),
          patch.object(providerCommands, 'notify') as notify_mock,
          patch('talon_user.lib.providerCommands.print') as print_mock,
      ):
          result = providerCommands._delegate_to_bar_cli('model_provider_status')
          if not result:
              raise SystemExit('delegation returned False when error payload present')
      notify_mock.assert_called_once_with('cli failed')
      printed = ' '.join(str(arg) for arg in print_mock.call_args[0])
      if 'cli failed' not in printed:
          raise SystemExit('debug log missing cli failed message')
      print('error payload handled')
    PY
    - helper:diff-snapshot=0 files changed
    - pointer: inline — command failed because `notify` was never called for the CLI error payload.
  - green | 2026-01-02T00:25:41Z | exit 0 | python3 - <<'PY'
      import sys
      from pathlib import Path
      from types import SimpleNamespace
      from unittest.mock import patch
      sys.path.insert(0, str(Path('.').resolve()))
      from bootstrap import bootstrap
      bootstrap()
      from talon_user.lib import providerCommands
      with (
          patch.object(providerCommands.settings, 'get', return_value=1),
          patch.object(providerCommands, '_bar_cli_command', return_value=Path('/tmp/bar')),
          patch.object(providerCommands.subprocess, 'run', return_value=SimpleNamespace(returncode=0, stdout='{"error":"cli failed"}', stderr='')),
          patch.object(providerCommands, 'notify') as notify_mock,
          patch('talon_user.lib.providerCommands.print') as print_mock,
      ):
          result = providerCommands._delegate_to_bar_cli('model_provider_status')
          if not result:
              raise SystemExit('delegation returned False when error payload present')
      notify_mock.assert_called_once_with('cli failed')
      printed = ' '.join(str(arg) for arg in print_mock.call_args[0])
      if 'cli failed' not in printed:
          raise SystemExit('debug log missing cli failed message')
      print('error payload handled')
    PY
    - helper:diff-snapshot=1 file changed, 33 insertions(+), 12 deletions(-)
    - pointer: inline — updated shim notifies and logs CLI error payloads.
  - removal | 2026-01-02T00:25:49Z | exit 1 | python3 - <<'PY'
      import subprocess
      content = subprocess.check_output(['git', 'show', 'HEAD:lib/providerCommands.py'], text=True)
      if 'error_message = payload.get("error")' in content:
          raise SystemExit('error payload handling already present in HEAD baseline')
      raise SystemExit('baseline missing error payload handling (expected removal)')
    PY
    - helper:diff-snapshot=0 files changed
    - pointer: inline — restoring the previous revision removes the error payload handling and recreates the red failure.
- rollback_plan: git checkout HEAD -- lib/providerCommands.py docs/adr/0063-go-cli-single-source-of-truth.work-log.md
- delta_summary: helper:diff-snapshot=1 file changed, 33 insertions(+), 12 deletions(-); `_delegate_to_bar_cli` now notifies and logs CLI error payloads (including drop_reason hints).
- loops_remaining_forecast: 6 loops remaining (tests, docs, payload helper refactor, helper tests, documentation wrap-up); confidence medium.
- residual_risks:
  - Error payloads still bypass structured drop-reason mapping; telemetry handshake work will address this.
- next_work:
  - Behaviour: add tests covering CLI error payload handling — python3 -m pytest _tests/test_provider_commands.py — future-shaping: assert notify/log expectations under the feature flag.
