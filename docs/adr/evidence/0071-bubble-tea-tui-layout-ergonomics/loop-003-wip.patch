diff --git a/cmd/bar/testdata/tui_smoke.json b/cmd/bar/testdata/tui_smoke.json
index 8c91e0d2..6501e43d 100644
--- a/cmd/bar/testdata/tui_smoke.json
+++ b/cmd/bar/testdata/tui_smoke.json
@@ -5,5 +5,5 @@
   ],
   "subject": "Smoke subject",
   "expected_preview": "=== TASK (DO THIS) ===\nReturn a todo list\n\n=== CONSTRAINTS (GUARDRAILS) ===\n1. Completeness (full): The response provides a thorough answer that covers all essential details for normal use.\n2. Scope (focus): The response concentrates on a single focal topic without drifting into tangents.\n\n=== PERSONA (STANCE) ===\n(none)\n\n=== SUBJECT (CONTEXT) ===\nSmoke subject\n",
-  "expected_view": "bar prompt editor (Bubble Tea prototype)\n\nStatus: Ready. Tab cycles focus · Ctrl+P palette · Ctrl+B copy CLI. Environment allowlist: (none). | Tokens: todo, focus | Preset: (none) | CLI: bar build todo focus --prompt 'Smoke subject' | Env: none\n\nSubject (PgUp/PgDn scroll · Home/End jump):\nSmoke subject   ← editing\n                         \n                         \n                         \n                         \n                         \n\nCommand (Enter runs without preview):\nEnter shell command (leave blank to opt out)\n\nHint: press ? for shortcut help · Ctrl+P toggles the palette · Leave command blank to opt out.\n\nResult & preview (PgUp/PgDn scroll · Home/End jump · Ctrl+T toggle condensed preview):\nResult pane (stdout/stderr):                                                    \n(no command has been executed)                                                  \n                                                                                \nPreview:                                                                        \n=== TASK (DO THIS) ===                                                          \nReturn a todo list                                                              \n                                                                                \n=== CONSTRAINTS (GUARDRAILS) ===                                                \n1. Completeness (full): The response provides a thorough answer that covers all \n2. Scope (focus): The response concentrates on a single focal topic without drif\nTokens: Static Prompt: todo — Return a todo list · Scope: focus — The response c\nUnset: Completeness, Method, Form, Channel, Directional, Voice, Audience, Tone, \n                                                                                \n                                                                                \n                                                                                \n                                                                                \n                                                                                \n                                                                                \n\nPress Ctrl+C or Esc to exit.\n"
+  "expected_view": "bar prompt editor (Bubble Tea prototype)\n\nStatus: Ready. Tab cycles focus · Ctrl+P palette · Ctrl+B copy CLI. Environment allowlist: (none). | Tokens: todo, focus | Preset: (none) | CLI: bar build todo focus --prompt 'Smoke subject' | Env: none\n\nSubject (PgUp/PgDn scroll · Home/End jump):\nSmoke subject   ← editing\n                         \n                         \n                         \n                         \n                         \n\nCommand (Enter runs without preview):\nEnter shell command (leave blank to opt out)\n\nHint: press ? for shortcut help · Ctrl+P toggles the palette · Leave command blank to opt out.\n\nResult summary:\n∅ No command executed yet · input optional · env (none)\n\nResult & preview (PgUp/PgDn scroll · Home/End jump · Ctrl+T toggle condensed preview):\nResult pane (stdout/stderr):                                                    \n(no command has been executed)                                                  \n                                                                                \nPreview:                                                                        \n=== TASK (DO THIS) ===                                                          \nReturn a todo list                                                              \n                                                                                \n=== CONSTRAINTS (GUARDRAILS) ===                                                \n1. Completeness (full): The response provides a thorough answer that covers all \n2. Scope (focus): The response concentrates on a single focal topic without drif\nTokens: Static Prompt: todo — Return a todo list · Scope: focus — The response c\nUnset: Completeness, Method, Form, Channel, Directional, Voice, Audience, Tone, \n                                                                                \n                                                                                \n                                                                                \n                                                                                \n                                                                                \n                                                                                \n\nPress Ctrl+C or Esc to exit.\n"
 }
diff --git a/internal/bartui/program.go b/internal/bartui/program.go
index 09602fe1..a32a1118 100644
--- a/internal/bartui/program.go
+++ b/internal/bartui/program.go
@@ -273,6 +273,8 @@ type commandResult struct {
 	Err         error
 	UsedPreview bool
 	EnvVars     []string
+	ExitCode    int
+	HasExitCode bool
 }
 
 type commandMode int
@@ -287,6 +289,18 @@ type commandFinishedMsg struct {
 	mode   commandMode
 }
 
+func exitCodeFromError(err error) (int, bool) {
+	if err == nil {
+		return 0, true
+	}
+	type exitCoder interface{ ExitCode() int }
+	var coder exitCoder
+	if errors.As(err, &coder) {
+		return coder.ExitCode(), true
+	}
+	return 0, false
+}
+
 type subjectReplacementPrompt struct {
 	source         string
 	newValue       string
@@ -684,21 +698,25 @@ func (m *model) renderResultViewportContent() string {
 		} else {
 			builder.WriteString("Input: (none)\n")
 		}
+		if m.lastResult.HasExitCode {
+			builder.WriteString(fmt.Sprintf("Exit code: %d\n", m.lastResult.ExitCode))
+		} else {
+			builder.WriteString("Exit code: (unknown)\n")
+		}
 		if m.lastResult.Err != nil {
-			builder.WriteString("Status: failed — ")
+			builder.WriteString("Status: failed\n")
+			builder.WriteString("Error: ")
 			builder.WriteString(m.lastResult.Err.Error())
 			builder.WriteString("\n")
 		} else {
 			builder.WriteString("Status: completed successfully\n")
 		}
 		builder.WriteString("Environment: ")
-		if len(m.lastResult.EnvVars) == 0 {
-			builder.WriteString("(none)\n")
-		} else {
-			builder.WriteString(strings.Join(m.lastResult.EnvVars, ", "))
-			builder.WriteString("\n")
-		}
+		builder.WriteString(strings.TrimPrefix(summarizeEnvList(m.lastResult.EnvVars), "env "))
+		builder.WriteString("\n")
+		builder.WriteString("\n")
 		builder.WriteString("Stdout:\n")
+
 		stdout := strings.TrimSpace(m.lastResult.Stdout)
 		if stdout == "" {
 			builder.WriteString("(empty)\n")
@@ -1602,7 +1620,16 @@ func (m *model) handleTokenPaletteKey(key tea.KeyMsg) (bool, tea.Cmd) {
 		return m.handlePaletteNavigation(1, key)
 	case tea.KeyEnter, tea.KeySpace:
 		if m.tokenPaletteFocus == tokenPaletteFocusFilter {
-			return false, nil
+			if len(m.tokenPaletteOptions) == 0 {
+				return true, nil
+			}
+			m.tokenPaletteFilter.Blur()
+			m.tokenPaletteFocus = tokenPaletteFocusOptions
+			if m.tokenPaletteOptionIndex < 0 || m.tokenPaletteOptionIndex >= len(m.tokenPaletteOptions) {
+				m.tokenPaletteOptionIndex = 0
+			}
+			m.refreshPaletteStatus()
+			return true, nil
 		}
 		m.applyPaletteSelection()
 		return true, nil
@@ -1708,6 +1735,31 @@ func shortenString(input string, limit int) string {
 	return string(runes[:limit-1]) + "…"
 }
 
+func summarizeEnvList(names []string) string {
+	if len(names) == 0 {
+		return "env (none)"
+	}
+	if len(names) <= 3 {
+		return "env " + strings.Join(names, ", ")
+	}
+	return fmt.Sprintf("env %d vars", len(names))
+}
+
+func unsetCategoryLabels(states []tokenCategoryState) []string {
+	var unset []string
+	for _, state := range states {
+		if len(state.selected) > 0 {
+			continue
+		}
+		label := state.category.Label
+		if label == "" {
+			label = state.category.Key
+		}
+		unset = append(unset, label)
+	}
+	return unset
+}
+
 func (m *model) tokensSummaryList() string {
 	if len(m.tokens) == 0 {
 		return "none"
@@ -1754,6 +1806,46 @@ func (m *model) renderStatusStrip() string {
 	return strings.Join(parts, " | ")
 }
 
+func (m *model) renderResultSummaryLine() string {
+	if m.commandRunning {
+		label := "input none"
+		if m.runningMode == commandModePreview {
+			label = "input preview"
+		}
+		env := summarizeEnvList(m.allowedEnv)
+		cmd := shortenString(m.runningCommand, 48)
+		if cmd == "" {
+			cmd = "(blank command)"
+		}
+		return fmt.Sprintf("… Running %q · %s · %s · Press Esc to cancel.", cmd, label, env)
+	}
+
+	if m.lastResult.empty() {
+		env := summarizeEnvList(m.allowedEnv)
+		return fmt.Sprintf("∅ No command executed yet · input optional · %s", env)
+	}
+
+	cmd := shortenString(m.lastResult.Command, 48)
+	if cmd == "" {
+		cmd = "(blank command)"
+	}
+	cmdQuoted := fmt.Sprintf("%q", cmd)
+	exitPart := "exit ?"
+	if m.lastResult.HasExitCode {
+		exitPart = fmt.Sprintf("exit %d", m.lastResult.ExitCode)
+	}
+	inputPart := "input none"
+	if m.lastResult.UsedPreview {
+		inputPart = "input preview"
+	}
+	env := summarizeEnvList(m.lastResult.EnvVars)
+	if m.lastResult.Err != nil {
+		reason := shortenString(m.lastResult.Err.Error(), 64)
+		return fmt.Sprintf("✖ Command %s failed: %s · %s · %s · %s", cmdQuoted, reason, exitPart, inputPart, env)
+	}
+	return fmt.Sprintf("✔ Command %s completed · %s · %s · %s", cmdQuoted, exitPart, inputPart, env)
+}
+
 func (m *model) renderTokenSummary(b *strings.Builder) {
 	if len(m.tokenStates) == 0 {
 		if len(m.tokens) == 0 {
@@ -1801,17 +1893,7 @@ func (m *model) renderTokenSummary(b *strings.Builder) {
 		b.WriteString("Tokens: " + strings.Join(selections, " · ") + "\n")
 	}
 
-	var unset []string
-	for _, state := range m.tokenStates {
-		if len(state.selected) > 0 {
-			continue
-		}
-		label := state.category.Label
-		if label == "" {
-			label = state.category.Key
-		}
-		unset = append(unset, label)
-	}
+	unset := unsetCategoryLabels(m.tokenStates)
 	if len(unset) > 0 {
 		b.WriteString("Unset: " + strings.Join(unset, ", ") + "\n")
 	}
@@ -1825,7 +1907,16 @@ func (m *model) renderTokenPalette(b *strings.Builder) {
 	if !m.tokenPaletteVisible {
 		return
 	}
-	b.WriteString("Token palette (Esc closes · Tab cycles focus · Enter toggles):\n")
+	summaryLine := "Token palette (Esc closes · Tab cycles focus · Enter applies option)"
+	active := m.tokensSummaryList()
+	if active != "" {
+		summaryLine += " · Active: " + shortenString(active, 40)
+	}
+	unset := unsetCategoryLabels(m.tokenStates)
+	if len(unset) > 0 {
+		summaryLine += " · Unset: " + shortenString(strings.Join(unset, ", "), 24)
+	}
+	b.WriteString(summaryLine + "\n")
 	filterPrefix := "    "
 	if m.tokenPaletteFocus == tokenPaletteFocusFilter {
 		filterPrefix = "  » "
@@ -1833,6 +1924,7 @@ func (m *model) renderTokenPalette(b *strings.Builder) {
 	b.WriteString(fmt.Sprintf("%sFilter: %s\n", filterPrefix, m.tokenPaletteFilter.View()))
 
 	b.WriteString("  Categories:\n")
+
 	for i, state := range m.tokenStates {
 		prefix := "      "
 		if m.tokenPaletteFocus == tokenPaletteFocusCategories && i == m.tokenCategoryIndex {
@@ -2267,6 +2359,10 @@ func (m model) View() string {
 
 	b.WriteString("Hint: press ? for shortcut help · Ctrl+P toggles the palette · Leave command blank to opt out.\n\n")
 
+	b.WriteString("Result summary:\n")
+	b.WriteString(m.renderResultSummaryLine())
+	b.WriteString("\n\n")
+
 	b.WriteString("Result & preview (PgUp/PgDn scroll · Home/End jump · Ctrl+T toggle condensed preview):\n")
 	b.WriteString(m.resultViewport.View())
 	b.WriteString("\n")
@@ -2631,6 +2727,7 @@ func (m *model) startCommand(mode commandMode) tea.Cmd {
 		if err == nil && ctx.Err() != nil {
 			err = ctx.Err()
 		}
+		exitCode, hasExitCode := exitCodeFromError(err)
 		return commandFinishedMsg{
 			result: commandResult{
 				Command:     command,
@@ -2639,6 +2736,8 @@ func (m *model) startCommand(mode commandMode) tea.Cmd {
 				Err:         err,
 				UsedPreview: mode == commandModePreview,
 				EnvVars:     allowedEnv,
+				ExitCode:    exitCode,
+				HasExitCode: hasExitCode,
 			},
 			mode: mode,
 		}
diff --git a/internal/bartui/program_test.go b/internal/bartui/program_test.go
index 46f671dd..111a2eb2 100644
--- a/internal/bartui/program_test.go
+++ b/internal/bartui/program_test.go
@@ -729,15 +729,49 @@ func TestTokenPaletteSummaryCondensedWhenVisible(t *testing.T) {
 	}
 
 	view := m.View()
-	if !strings.Contains(view, "Token palette (Esc closes · Tab cycles focus · Enter toggles):") {
+	if !strings.Contains(view, "Token palette (Esc closes · Tab cycles focus · Enter applies option)") {
 		t.Fatalf("expected palette section to be rendered, got view:\n%s", view)
 	}
+	if !strings.Contains(view, "Active:") {
+		t.Fatalf("expected palette summary to list active tokens, got view:\n%s", view)
+	}
 	if strings.Contains(view, "Tokens (Tab focuses tokens · Ctrl+P opens palette):") {
 		t.Fatalf("expected condensed summary to replace default token header, got view:\n%s", view)
 	}
 }
 
+func TestTokenPaletteEnterMovesFocusToOptions(t *testing.T) {
+	opts := Options{
+		Tokens:          []string{"todo", "focus"},
+		TokenCategories: defaultTokenCategories(),
+		Preview:         func(subject string, tokens []string) (string, error) { return "preview:" + subject, nil },
+		ClipboardRead:   func() (string, error) { return "", nil },
+		ClipboardWrite:  func(string) error { return nil },
+		RunCommand: func(context.Context, string, string, map[string]string) (string, string, error) {
+			return "", "", nil
+		},
+		CommandTimeout: time.Second,
+	}
+	m := newModel(opts)
+	m, _ = updateModel(t, m, tea.KeyMsg{Type: tea.KeyTab})
+	m, _ = updateModel(t, m, tea.KeyMsg{Type: tea.KeyCtrlP})
+	if m.tokenPaletteFocus != tokenPaletteFocusFilter {
+		t.Fatalf("expected palette focus to start on filter, got %v", m.tokenPaletteFocus)
+	}
+	m, _ = updateModel(t, m, tea.KeyMsg{Type: tea.KeyEnter})
+	if m.tokenPaletteFocus != tokenPaletteFocusOptions {
+		t.Fatalf("expected Enter to move focus to options, got %v", m.tokenPaletteFocus)
+	}
+	if len(m.tokenPaletteOptions) == 0 {
+		t.Fatalf("expected palette options to be populated")
+	}
+	if m.tokenPaletteOptionIndex < 0 || m.tokenPaletteOptionIndex >= len(m.tokenPaletteOptions) {
+		t.Fatalf("expected palette option index to be within range, got %d", m.tokenPaletteOptionIndex)
+	}
+}
+
 func TestCtrlRuneOpensPalette(t *testing.T) {
+
 	opts := Options{
 		Tokens:          []string{"todo", "focus"},
 		TokenCategories: defaultTokenCategories(),
@@ -817,6 +851,9 @@ func TestPaletteRemainsVisibleWithinWindowHeight(t *testing.T) {
 	if !strings.Contains(windowSlice, "Token palette (Esc closes") {
 		t.Fatalf("expected token palette block within the terminal height window, got:\n%s", windowSlice)
 	}
+	if !strings.Contains(windowSlice, "Active:") {
+		t.Fatalf("expected token palette summary to include active tokens within the window, got:\n%s", windowSlice)
+	}
 }
 
 func TestTokenPaletteResetToPreset(t *testing.T) {
@@ -1036,6 +1073,123 @@ func TestHelpOverlayMentionsCopyCommandPaletteHint(t *testing.T) {
 	}
 }
 
+func TestResultSummaryNoCommand(t *testing.T) {
+	opts := Options{
+		Tokens:          []string{"todo"},
+		TokenCategories: defaultTokenCategories(),
+		Preview:         func(subject string, tokens []string) (string, error) { return "preview:" + subject, nil },
+		ClipboardRead:   func() (string, error) { return "", nil },
+		ClipboardWrite:  func(string) error { return nil },
+		RunCommand: func(context.Context, string, string, map[string]string) (string, string, error) {
+			return "", "", nil
+		},
+		CommandTimeout: time.Second,
+	}
+	m := newModel(opts)
+	view := m.View()
+	if !strings.Contains(view, "Result summary:") {
+		t.Fatalf("expected result summary heading in view, got:\n%s", view)
+	}
+	if !strings.Contains(view, "∅ No command executed yet") {
+		t.Fatalf("expected default result summary, got:\n%s", view)
+	}
+}
+
+func TestResultSummaryRunning(t *testing.T) {
+	opts := Options{
+		Tokens:          []string{"todo"},
+		TokenCategories: defaultTokenCategories(),
+		Preview:         func(subject string, tokens []string) (string, error) { return "preview:" + subject, nil },
+		ClipboardRead:   func() (string, error) { return "", nil },
+		ClipboardWrite:  func(string) error { return nil },
+		RunCommand: func(context.Context, string, string, map[string]string) (string, string, error) {
+			return "", "", nil
+		},
+		CommandTimeout: time.Second,
+	}
+	m := newModel(opts)
+	m.commandRunning = true
+	m.runningCommand = "echo hello"
+	m.runningMode = commandModePreview
+	m.allowedEnv = []string{"FOO"}
+	view := m.View()
+	if !strings.Contains(view, "Running \"echo hello\"") {
+		t.Fatalf("expected running summary with command, got:\n%s", view)
+	}
+	if !strings.Contains(view, "input preview") {
+		t.Fatalf("expected running summary to note preview input, got:\n%s", view)
+	}
+	if !strings.Contains(view, "env FOO") {
+		t.Fatalf("expected running summary to list environment, got:\n%s", view)
+	}
+}
+
+func TestResultSummaryLastResultSuccess(t *testing.T) {
+	opts := Options{
+		Tokens:          []string{"todo"},
+		TokenCategories: defaultTokenCategories(),
+		Preview:         func(subject string, tokens []string) (string, error) { return "preview:" + subject, nil },
+		ClipboardRead:   func() (string, error) { return "", nil },
+		ClipboardWrite:  func(string) error { return nil },
+		RunCommand: func(context.Context, string, string, map[string]string) (string, string, error) {
+			return "", "", nil
+		},
+		CommandTimeout: time.Second,
+	}
+	m := newModel(opts)
+	m.lastResult = commandResult{
+		Command:     "echo hello",
+		Stdout:      "hello\n",
+		UsedPreview: false,
+		EnvVars:     []string{},
+		ExitCode:    0,
+		HasExitCode: true,
+	}
+	view := m.View()
+	if !strings.Contains(view, "✔ Command \"echo hello\" completed") {
+		t.Fatalf("expected success summary, got:\n%s", view)
+	}
+	if !strings.Contains(view, "exit 0") {
+		t.Fatalf("expected success summary to include exit code, got:\n%s", view)
+	}
+}
+
+func TestResultSummaryLastResultFailure(t *testing.T) {
+	opts := Options{
+		Tokens:          []string{"todo"},
+		TokenCategories: defaultTokenCategories(),
+		Preview:         func(subject string, tokens []string) (string, error) { return "preview:" + subject, nil },
+		ClipboardRead:   func() (string, error) { return "", nil },
+		ClipboardWrite:  func(string) error { return nil },
+		RunCommand: func(context.Context, string, string, map[string]string) (string, string, error) {
+			return "", "", nil
+		},
+		CommandTimeout: time.Second,
+	}
+	m := newModel(opts)
+	m.lastResult = commandResult{
+		Command:     "echo boom",
+		UsedPreview: true,
+		EnvVars:     []string{"FOO"},
+		Err:         errors.New("boom"),
+		ExitCode:    1,
+		HasExitCode: true,
+	}
+	view := m.View()
+	if !strings.Contains(view, "✖ Command \"echo boom\" failed") {
+		t.Fatalf("expected failure summary, got:\n%s", view)
+	}
+	if !strings.Contains(view, "exit 1") {
+		t.Fatalf("expected failure summary to include exit code, got:\n%s", view)
+	}
+	if !strings.Contains(view, "input preview") {
+		t.Fatalf("expected failure summary to reference preview input, got:\n%s", view)
+	}
+	if !strings.Contains(view, "env FOO") {
+		t.Fatalf("expected failure summary to list env vars, got:\n%s", view)
+	}
+}
+
 func TestPaletteOpenStatusMentionsCopyCommand(t *testing.T) {
 	opts := Options{
 		Tokens:          []string{"todo"},
